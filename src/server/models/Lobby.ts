import WebSocket from 'ws';
import GameEngine from "./GameEngine";
import Events from "../enums/Events";
import GameEngineImpl from "../GameEngineImpl";
import Server from "./Server";
import NewRoundEvent from "../../shared/events/NewRoundEvent";
import BeginGameEvent from "../../shared/events/BeginGameEvent";
import RoundOverEvent from "../../shared/events/RoundOverEvent";
import NewLobbyEvent from "../../shared/events/NewLobbyEvent";

/**
 * A representation of a Lobby, which is responsible for handling messages to and from this Lobby instance.
 * The event loop consists of:
 * [[connectPlayer]] (wait for two players) -> [[beginGame]] (wait for messages)
 * -> [[choiceHandler]] (wait for both players to make a choice)
 * -> [[checkForAllChoicesMade]] -> [[beginRound]] -> [[choiceHandler]]
 */
export default class Lobby {
    private readonly _id: string;

    /**
     * How many points a player has to reach before the game is over
     */
    private readonly _FIRST_TO: number;

    /**
     * How many milliseconds to wait after a round over to initiate a new round
     */
    private readonly _ROUND_DELAY: number;

    private readonly _players: WebSocket[];

    private readonly _game: GameEngine;

    /**
     * Callback to the parent server instance (calls [[Server.destroyLobby]] at game over)
     */
    private _server: Server;

    constructor(id: string, server: Server, firstTo: number = 5, roundDelay: number = 5000) {
        this._id = id;
        this._players = [];
        this._game = new GameEngineImpl();
        this._server = server;
        this._ROUND_DELAY = roundDelay;
        this._FIRST_TO = firstTo;
    }

    /**
     * Store the connection of a player into this Lobby as either player 1 or player 2.
     * This is determined from the size of [[_players]], as each connection is automatically
     * pushed into [[_players]]. If this is player 1, a [[NewLobbyEvent]] is sent to the
     * player.
     *
     * Once [[_players]].length reaches 2, [[beginGame]] is called
     * @param connection The player to be added into this lobby
     */
    connectPlayer(connection: WebSocket) {
        this._players.push(connection);

        if (this._players.length === 1) {
            let event: NewLobbyEvent = {
                event: 'new lobby',
                lobbyID: this._id
            };

            connection.send(JSON.stringify(event));
        } else {
            console.log(`Beginning lobby ${this._id}`);

            this.beginGame();
        }
    }

    /**
     * Sends a [[BeginGameEvent]] to both players and sets the `.on('message', ...)` handlers
     * to call [[choiceHandler]]
     */
    private beginGame() {
        // Both players have connected to the lobby
        let event: BeginGameEvent = {
            event: 'begin game',
            player1: this._game.getPlayer1().toJSON(),
            player2: this._game.getPlayer2().toJSON()
        };

        this.sendToPlayers(JSON.stringify(event));

        this._players[0].on('message', (message) => {
            this.choiceHandler(message, this._players[0]);
        });

        this._players[1].on('message', (message) => {
            this.choiceHandler(message, this._players[1]);
        });
    }

    /**
     * Sets the choice of `player` to the corresponding `message` based on [[Events]]. Afterwards, this
     * will call [[checkForAllChoicesMade]]
     * @param message Message received from `player`
     * @param player The player the message was sent from
     */
    public choiceHandler(message: WebSocket.Data, player: WebSocket) {
        let choice: Events | null = null;

        switch (message) {
            case "shoot":
                choice = Events.SHOOT;
                break;
            case "reload":
                choice = Events.RELOAD;
                break;
            case "block":
                choice = Events.BLOCK;
                break;
        }

        if (choice !== null) {

            if (player === this._players[0]) {
                this._game.getPlayer1().setChoice(choice);
            } else {
                this._game.getPlayer2().setChoice(choice);
            }

            this.checkForAllChoicesMade();
        }
    }

    /**
     * Checks to see if both players have made a choice. If so, a [[RoundOverEvent]] is generated by calling [[GameEngineImpl.processRound]]
     * and is sent to both players. This method waits [[_ROUND_DELAY]] milliseconds until it then either calls
     * [[endGame]] if either player has reached [[_FIRST_TO]] points, otherwise it will begin a new round
     * by calling [[beginRound]].
     */
    private checkForAllChoicesMade() {
        // If both players have made their choice, process the results
        if (this._game.getPlayer1().getChoice() && this._game.getPlayer2().getChoice()) {
            // Informs players of the result of the round in the format
            // <RoundState> <Player 1 Event> <Player 2 Event>
            // i.e. draw shoot block
            let event: RoundOverEvent = {
                event: 'round over',
                results: this._game.processRound(),
                player1: this._game.getPlayer1().toJSON(),
                player2: this._game.getPlayer2().toJSON()
            };

            this.sendToPlayers(JSON.stringify(event));

            // Wait five seconds until the next round starts
            // (allows players time to read what happened in the round)
            setTimeout(() => {
                // If a player has reached the point limit, the game is over and thus the lobby
                // should be destroyed
                if (this._game.getPlayer1().getPoints() === this._FIRST_TO) {
                    this.endGame('player 1');
                } else if (this._game.getPlayer2().getPoints() === this._FIRST_TO) {
                    this.endGame('player 2');
                } else {
                    this.beginRound();
                }
            }, this._ROUND_DELAY);
        }
    }

    /**
     * Sends details of the game's state (i.e. player details such as number of bullets,
     * points, etc.) to each player connected to the lobby
     */
    private beginRound() {
        let event: NewRoundEvent = {
            event: 'new round',
        };

        this.sendToPlayers(JSON.stringify(event));
    }

    /**
     * Sends each player a message declaring who won, before calling [[Server.destroyLobby]] to remove the lobby
     * @param victor The winner of this lobby (either player 1 or player 2)
     */
    private endGame(victor: string) {
        this.sendToPlayers('end ' + victor);

        this._server.destroyLobby(this._id);
    }

    /**
     * A utility method to send a message to both players connected to the lobby
     * @param message The message to be sent
     */
    private sendToPlayers(message: string) {
        this._players[0].send(message);
        this._players[1].send(message);
    }

    getID() {
        return this._id;
    }

    getPlayers(): WebSocket[] {
        return this._players.slice();
    }

    getGameEngine() {
        return this._game;
    }
}